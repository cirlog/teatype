#!/usr/bin/env python3.11

# Copyright (C) 2024-2026 Burak GÃ¼naydin
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# Standard-library imports
import time

# Third-party imports
import psutil
from teatype.cli import BaseCLI
from teatype.comms.ipc.redis import RedisConnectionPool
from teatype.io import clear_shell, enable_sudo, path, prompt, shell, softkill
from teatype.logging import *

class Redis(BaseCLI):
    def meta(self):
        return {
            'name': 'redis',
            'shorthand': 'rs',
            'help': 'Redis module CLI tool',
            "commands": [
                {
                    'name': 'start',
                    'shorthand': 'st',
                    'help': 'Start the Redis server.'
                },
                {
                    'name': 'status',
                    'shorthand': 'st',
                    'help': 'Check the status of the Redis server.'  
                },
                {
                    'name': 'stop',
                    'shorthand': 'sp',
                    'help': 'Stop the Redis server.'
                }
            ],
            "flags": [
                {
                    'shorthand': 'ss',
                    'name': 'show-status',
                    'help': 'Show Redis server status after executing the command.',
                    'required': False
                }
            ]
        }
    
    def install(self, parent_directory:str) -> bool:
        redis_installed = shell('which redis-server', mute=True)
        if redis_installed == 0:
            return
        
        install_redis = prompt('Redis server is not installed. Proceed with installation?')
        if not install_redis:
            println()
            err('Redis installation aborted by user.', exit=True, pad_after=1, use_prefix=False, verbose=False)     
        
        REDIS_VERSION = '7.4.1'

        # Update package lists and install pkg-config
        shell('apt-get update -y', sudo=True)
        shell('apt-get install -y build-essential pkg-config tcl', sudo=True)

        # Create a temporary directory for the Redis source code
        work_directory = path.join(parent_directory, 'dist')
        path.create(work_directory)
        path.cd(work_directory)

        # Download and extract Redis source code from GitHub
        download_url = f'https://github.com/redis/redis/archive/refs/tags/{REDIS_VERSION}.tar.gz'
        shell(f'wget {download_url} -O redis.tar.gz')
        shell('tar -xzf redis.tar.gz')

        # Compile and install Redis from source
        redis_source_directory = path.join(work_directory, f'redis-{REDIS_VERSION}')
        path.cd(redis_source_directory)
        shell('make', sudo=True)
        shell('make install', sudo=True)

        path.cd(parent_directory)

        # Clean up temporary files and directories
        path.delete(work_directory)

    def is_running(self) -> tuple[bool, None|int]:
        found = False
        process_pid = None
        for process in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if process.info['cmdline'] is None:
                    continue
                
                if 'redis-server' in ' '.join(process.info['cmdline']):
                    process_pid = process.info['pid']
                    found = True
            except (psutil.NoSuchProcess, psutil.AccessDenied, KeyError):
                continue
            except:
                found = False
        
        return found, process_pid
    
    def start(self, parent_directory:str) -> None:
        shell('echo "never" | sudo tee /sys/kernel/mm/transparent_hugepage/enabled', mute=True)
        hint('Disabled Transparent Huge Pages to reduce Redis latency', include_symbol=True, use_prefix=False)
        println()
        
        shell('sysctl -w vm.overcommit_memory=1', mute=True, sudo=True)
        hint('Enabled memory overcommit for optimal Redis performance', include_symbol=True, use_prefix=False)
        println()
        
        logs_directory = path.join(parent_directory, 'logs')
        path.create(path.join(logs_directory, 'logs'))
        shell(f'redis-server {parent_directory}/config/redis.conf > {logs_directory}/redis.log 2>&1 &')
        success('Redis server started successfully.', include_symbol=True)
        println()
    
    def status(self, is_running:bool) -> None:
        if is_running:
            client_buffer = []
            old_client_buffer = []
            
            log_buffer = []
            old_log_buffer = []
            
            redis_log_path = path.join(path.caller_parent(reverse_depth=2), 'logs', 'redis.log')
            
            self.redis_connection_pool = RedisConnectionPool(verbose_logging=False)
            self.redis_connection_pool.establish_connection()
            
            while True:
                try:
                    clients = self.redis_connection_pool._connection.client_list()
                    client_buffer = []
                    for client in clients:
                        client_buffer.append({
                            'addr': client.get('addr'),
                            'id': client.get('id'),
                            'laddr': client.get('laddr'),
                            'name': client.get('name')
                        })
                        
                    log_buffer = shell('tail -n 10 ' + redis_log_path,
                                   mute=True,
                                   return_stdout=True)
                    
                    if log_buffer != old_log_buffer or client_buffer != old_client_buffer:
                        clear_shell()
                        success('Redis server is running.', include_symbol=True)
                        println()
                        hint('Monitoring Redis server logs. Press Ctrl + C to exit log monitoring.',
                             use_prefix=False)
                        println()
                        
                        for line in log_buffer:
                            print(line)
                            
                        println()
                        if len(client_buffer) == 0:
                            log('No connected clients found.')
                        else:
                            success(f'Connected clients ({len(client_buffer)}):')
                            for index, client in enumerate(client_buffer):
                                println()
                                print(f'    Client {index + 1}:')
                                print(f'        ID: {client.get("id")}')
                                print(f'        Name: {client.get("name")}')
                                print(f'        Address: {client.get("addr")}')
                                print(f'        Local Address: {client.get("laddr")}')
                            
                        println()
                    
                    if client_buffer != old_client_buffer:
                        old_client_buffer = client_buffer
                        
                    if log_buffer != old_log_buffer:
                        old_log_buffer = log_buffer
                        
                    time.sleep(0.25)
                except KeyboardInterrupt:
                    println()
                    warn('Exited log monitoring.', pad_after=1, use_prefix=False)
                    break
        else:
            err('Redis server is not running.',
                include_symbol=True,
                use_prefix=False,
                verbose=False)
            println()
        
    def execute(self):
        enable_sudo()
        
        parent_directory = path.caller_parent(reverse_depth=2)
        is_running, process_pid = self.is_running()
        self.install(parent_directory)
        
        match self.get_command():
            case 'start':
                if is_running:
                    warn('Redis server is already running. Use `tt redis stop` to shut it down.',
                         include_symbol=True,
                         use_prefix=False)
                    println()
                else:
                    self.start(parent_directory)
                    if self.get_flag('show-status'):
                        warn('Waiting 2 seconds for Redis server to initialize ...', use_prefix=False)
                        time.sleep(2.0)
                        is_running, process_pid = self.is_running()
                        self.status(is_running)
            case 'status':
                self.status(is_running)
            case 'stop':
                if not is_running:
                    log('Redis server is not running. No action taken.')
                    println()
                else:
                    softkill(['redis-server'])

if __name__ == '__main__':
    Redis()