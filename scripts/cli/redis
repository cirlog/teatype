#!/usr/bin/env python3.11

# Copyright (C) 2024-2025 Burak GÃ¼naydin
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# Standard-library imports
import os
import signal
import time
from pprint import pprint
# Third-party imports
import psutil
from teatype.cli import BaseCLI
from teatype.comms.ipc.redis import RedisConnectionPool
from teatype.io import clear_shell, enable_sudo, file, path, prompt, shell
from teatype.logging import *
from teatype.toolkit import dt

class Redis(BaseCLI):
    def meta(self):
        return {
            'name': 'redis',
            'shorthand': 'rs',
            'help': 'Redis module CLI tool',
            "commands": [
                {
                    'name': 'start',
                    'shorthand': 'st',
                    'help': 'Start the Redis server.'
                },
                {
                    'name': 'status',
                    'shorthand': 'st',
                    'help': 'Check the status of the Redis server.'  
                },
                {
                    'name': 'stop',
                    'shorthand': 'sp',
                    'help': 'Stop the Redis server.'
                }
            ]
        }
    
    def install(self, parent_directory:str) -> bool:
        redis_installed = shell('which redis-server', mute=True)
        if redis_installed == 0:
            return
        
        install_redis = prompt('Redis server is not installed. Proceed with installation?',
                               options=['Y', 'n'])
        if not install_redis:
            println()
            err('Redis installation aborted by user.', exit=True, pad_after=1, use_prefix=False, verbose=False)     
        
        REDIS_VERSION = '7.4.1'

        # Update package lists and install pkg-config
        shell('apt-get update -y', sudo=True)
        shell('apt-get install -y build-essential pkg-config tcl', sudo=True)

        # Create a temporary directory for the Redis source code
        work_directory = path.join(parent_directory, '~temp')
        path.create(work_directory)
        path.cd(work_directory)

        # Download and extract Redis source code from GitHub
        download_url = f'https://github.com/redis/redis/archive/refs/tags/{REDIS_VERSION}.tar.gz'
        shell(f'wget {download_url} -O redis.tar.gz')
        shell('tar -xzf redis.tar.gz')

        # Compile and install Redis from source
        redis_source_directory = path.join(work_directory, f'redis-{REDIS_VERSION}')
        path.cd(redis_source_directory)
        shell('make', sudo=True)
        shell('make install', sudo=True)

        path.cd(parent_directory)

        # Clean up temporary files and directories
        path.delete(work_directory)

        file.write(redis_installed_flag_path, f'Installed successfully at {dt.now()}')
        
    def is_running(self) -> tuple[bool, None|int]:
        found = False
        process_pid = None
        for process in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if process.info['cmdline'] is None:
                    continue
                
                if 'redis-server' in ' '.join(process.info['cmdline']):
                    process_pid = process.info['pid']
                    found = True
            except (psutil.NoSuchProcess, psutil.AccessDenied, KeyError):
                continue
            except:
                found = False
        
        return found, process_pid
    
    def start(self, parent_directory:str) -> None:
        enable_sudo()
        
        println()
        
        shell('echo "never" | sudo tee /sys/kernel/mm/transparent_hugepage/enabled', mute=True)
        hint('Disabled Transparent Huge Pages to reduce Redis latency', include_symbol=True, use_prefix=False)
        println()
        
        shell('sysctl -w vm.overcommit_memory=1', mute=True, sudo=True)
        hint('Enabled memory overcommit for optimal Redis performance', include_symbol=True, use_prefix=False)
        println()
        
        logs_directory = path.join(parent_directory, 'logs')
        path.create(path.join(logs_directory, 'logs'))
        shell(f'redis-server {parent_directory}/config/redis.conf > {logs_directory}/redis.log 2>&1 &')
        success('Redis server started successfully.', include_symbol=True)
        println()
    
    def status(self, is_running:bool) -> None:
        if is_running:
            client_buffer = []
            old_client_buffer = []
            
            log_buffer = []
            old_log_buffer = []
            
            redis_log_path = path.join(path.caller_parent(reverse_depth=2), 'logs', 'redis.log')
            
            self.redis_connection_pool = RedisConnectionPool(verbose_logging=False)
            self.redis_connection_pool.establish_connection()
            
            while True:
                try:
                    clients = self.redis_connection_pool._connection.client_list()
                    client_buffer = []
                    for client in clients:
                        client_buffer.append({
                            'addr': client.get('addr'),
                            'id': client.get('id'),
                            'laddr': client.get('laddr'),
                            'name': client.get('name')
                        })
                        
                    log_buffer = shell('tail -n 10 ' + redis_log_path,
                                   mute=True,
                                   return_stdout=True)
                    
                    if log_buffer != old_log_buffer or client_buffer != old_client_buffer:
                        clear_shell()
                        println()
                        success('Redis server is running.', include_symbol=True)
                        println()
                        hint('Monitoring Redis server logs. Press Ctrl + C to exit log monitoring.',
                             use_prefix=False)
                        println()
                        
                        for line in log_buffer:
                            print(line)
                            
                        println()
                        if len(client_buffer) == 0:
                            log('No connected clients found.')
                        else:
                            success(f'Connected clients ({len(client_buffer)}):')
                            for index, client in enumerate(client_buffer):
                                println()
                                print(f'    Client {index + 1}:')
                                print(f'        ID: {client.get("id")}')
                                print(f'        Name: {client.get("name")}')
                                print(f'        Address: {client.get("addr")}')
                                print(f'        Local Address: {client.get("laddr")}')
                            
                        println()
                    
                    if client_buffer != old_client_buffer:
                        old_client_buffer = client_buffer
                        
                    if log_buffer != old_log_buffer:
                        old_log_buffer = log_buffer
                        
                    time.sleep(0.25)
                except KeyboardInterrupt:
                    println()
                    warn('Exited log monitoring.', pad_after=1, use_prefix=False)
                    break
        else:
            println()
            err('Redis server is not running.',
                include_symbol=True,
                use_prefix=False,
                verbose=False)
            println()
        
    def stop(self, parent_directory, process_pid:int) -> None:
        def _is_process_running(pid:int) -> bool:
            """
            Check if a process with the given PID is currently running.

            Args:
                pid (int): Process ID to check.

            Returns:
                bool: True if the process is running, False otherwise.
            """
            try:
                # Sending signal 0 does not kill the process but checks its existence
                os.kill(pid, 0)
                return True
            except OSError as ose:
                # Permission error, request sudo access
                if ose.errno == 1:
                    err('OS denied permission access for process. Please run the script with sudo.', pad_after=1, exit=True, verbose=False)
                return False

        def _attempt_stop(pid:int, signal_type:int, max_attempts:int, signal_name:str) -> bool:
            """
            Attempt to stop a process by sending a specific signal, retrying up to a maximum number of attempts.

            Args:
                pid (int): Process ID to stop.
                signal_type (int): Signal to send (e.g., signal.SIGTERM).
                max_attempts (int): Maximum number of attempts to send the signal.
                signal_name (str): Name of the signal for logging purposes.

            Returns:
                bool: True if the process was successfully stopped, False otherwise.
            """
            attempts = 0
            while _is_process_running(pid):
                if attempts >= max_attempts:
                    # Warn if maximum attempts have been reached without success
                    warn(f'Failed to stop process (PID: {pid}) after {max_attempts} attempts with {signal_name}.')
                    return False
                # Log the attempt to stop the process
                log(f'Attempt {attempts + 1} to stop process (PID: {pid}) with {signal_name}...')
                try:
                    # Send the specified signal to the process
                    os.kill(pid, signal_type)
                except OSError as e:
                    # Log an error if sending the signal fails
                    err(f'Error sending signal {signal_name} to PID {pid}: {e}')
                    return False
                attempts += 1
                # Wait for a short period before the next attempt
                sleep = 1
                if self.get_flag('sleep'):
                    sleep = self.get_flag('sleep')
                time.sleep(sleep)
            # Log success if the process has been stopped
            log(f'Process (PID: {pid}) stopped using {signal_name}.')
            return True

        def _stop_process(pid:int) -> bool:
            """
            Attempt to stop a process using SIGINT, then SIGTERM, and finally SIGKILL if necessary.

            Args:
                pid (int): Process ID to stop.

            Returns:
                bool: True if the process was successfully stopped, False otherwise.
            """
            MAX_SIGINT_ATTEMPTS = 3
            MAX_SIGTERM_ATTEMPTS = 3
            MAX_SIGKILL_ATTEMPTS = 3
            # Attempt to stop the process using SIGINT
            if not _attempt_stop(pid, signal.SIGINT, MAX_SIGINT_ATTEMPTS, 'SIGINT'):
                # Warn and attempt to stop using SIGTERM if SIGINT fails
                warn('SIGINT attempts failed. Trying with SIGTERM...')
                if not _attempt_stop(pid, signal.SIGTERM, MAX_SIGTERM_ATTEMPTS, 'SIGTERM'):
                    # Warn and attempt to stop using SIGKILL if SIGTERM fails
                    warn('SIGTERM attempts failed. Trying with SIGKILL...')
                    if not _attempt_stop(pid, signal.SIGKILL, MAX_SIGKILL_ATTEMPTS, 'SIGKILL'):
                        # Log an error if all attempts fail
                        err('SIGKILL failed. Manual intervention required.')
                        return False
            return True
        
        def recursive_kill():
            """
            Recursively attempt to kill all processes in the process_pids list until no processes remain.
            """

            # Execute the is_running to update the list of process PIDs
            is_running, process_pid = self.is_running()
            if not is_running:
                log('No running Redis server processes found. Exiting recursive kill.')
                return
            
            if _is_process_running(process_pid):
                # Attempt to stop the process and log the result
                if _stop_process(process_pid):
                    log(f'Process (PID: "{process_pid}") has been stopped.')
                else:
                    # Log an error if the process could not be stopped
                    err(f'Process (PID: "{process_pid}") could not be stopped. Manual intervention required.')
            else:
                # Log if the process is not running
                log(f'Process (PID: "{process_pid}") is not running.')
            println()
                    
        recursive_kill()

    def execute(self):
        enable_sudo()
        
        parent_directory = path.caller_parent(reverse_depth=2)
        is_running, process_pid = self.is_running()
        self.install(parent_directory)
        
        match self.get_command():
            case 'start':
                if is_running:
                    println()
                    warn('Redis server is already running. Use `tt redis stop` to shut it down.',
                         include_symbol=True,
                         use_prefix=False)
                    println()
                else:
                    self.start(parent_directory)
            case 'status':
                self.status(is_running)
            case 'stop':
                if not is_running:
                    println()
                    log('Redis server is not running. No action taken.')
                    println()
                else:
                    self.stop(parent_directory, process_pid)

if __name__ == '__main__':
    Redis()